# java-university-project
## [Лабораторна робота 6](https://github.com/BohdanSharubin/java-university-project/tree/lab6)
### Вимоги до реалізації
- Використайте код практичної роботи №5 як базу та розширте його відповідно до вимог цього завдання.
- Додайте до основного класу конструктор копіювання.
- Реалізуйте статичне поле для підрахунку кількості створених об’єктів класу, а також відповідний статичний гетер.
- Протестуйте роботу статичного поля та статичного методу в драйвері програми.
- Продемонструйте принцип агрегації:
  - або створіть новий допоміжний клас, який агрегує ваш існуючий клас (у цьому випадку новий клас є основним);
  - або додайте до існуючого класу поле іншого класу, який агрегується (у цьому випадку основним є вже наявний клас).
- Якщо деякі атрибути класу мають фіксований набір можливих значень, використовуйте перерахування (enum). Перерахування повинні бути реалізовані в окремих файлах.
- Усі класи та методи повинні бути задокументовані відповідно до пояснень під час лекцій і лабораторних занять.
- Забороняється використовувати тип var, Stream API або бібліотеку java.util.stream у межах цієї лабораторної роботи.
## [Лабораторна робота 7](https://github.com/BohdanSharubin/java-university-project/tree/lab7)
### Вимоги до реалізації
- Продовжуємо в репозиторії на основі виконаної практичної роботи №6.
- Видаліть зі структури програми статичні поля, статичні методи та пов’язаний із ними функціонал.
- Видаліть реалізацію агрегації та весь функціонал, який був пов’язаний з додатковим класом/полем агрегації.
- Створіть два похідні класи, які успадковуються від вашого існуючого (базового) класу.
- Продемонструйте поліморфізм: об’єкти похідних класів мають оброблятися як об’єкти базового типу.
- Додайте в консольне меню окремі опції для створення об’єктів похідних класів.
- Усі створені об’єкти (базового та похідних типів) повинні додаватися до однієї колекції ArrayList.
- Ретельно протестуйте весь код, зокрема сценарії створення об’єктів різних типів та коректність виведення інформації.
## [Лабораторна робота 8](https://github.com/BohdanSharubin/java-university-project/tree/lab8)
### Вимоги до реалізації
- Створіть новий проєкт на основі виконаної практичної роботи №7.
- Додайте ще два класи до вашої ієрархії, забезпечивши наявність додаткових атрибутів та відповідного функціоналу.
- Ієрархія класів повинна мати логічний зміст (класи та їх зв’язки повинні відповідати предметній області).
- Загалом у проєкті повинні бути: 5 класів ієрархії + драйвер.
- Усі створені об’єкти незалежно від конкретного типу повинні зберігатися в одній внутрішній колекції ArrayList.
- На початку роботи програми внутрішня колекція повинна бути порожньою. Забороняється використовувати будь-яке попереднє заповнення або зчитування з файлів.
- Не використовуйте файли для зберігання або завантаження даних у межах цієї роботи.
- Ретельно протестуйте весь код, зокрема коректність роботи меню, створення об’єктів різних типів і виведення інформації про колекцію.
## [Лабораторна робота 9](https://github.com/BohdanSharubin/java-university-project/tree/lab9)
### Вимоги до реалізації
- Створіть новий проєкт на основі практичної роботи №8.
- Усі обмеження та вимоги попередніх робіт, обговорені під час занять, залишаються чинними і повинні бути дотримані в цій роботі.
- Забороняється використовувати тип var, оператор goto або Stream API у межах цього завдання.
- Інформація про об’єкти ієрархії зберігається у файлі input.txt.
- Під час запуску програми дані з файлу повинні бути зчитані, на їх основі повинні бути створені об’єкти відповідних класів і додані до внутрішньої колекції ArrayList.
- Під час завершення роботи програми інформація про всі об’єкти з внутрішньої колекції ArrayList повинна бути записана до файлу.
- Додайте необхідний функціонал для підтримки читання та запису даних, зокрема обробку помилкових або некоректних даних у файлі.
- Ретельно протестуйте весь код, перевіривши коректність зчитування, створення об’єктів, додавання в колекцію та збереження даних у файл.
## [Лабораторна робота 10](https://github.com/BohdanSharubin/java-university-project/tree/lab10)
### Вимоги до реалізації
- Пошук має бути реалізований через власні методи (без Stream API).
- Код повинен бути читабельним і структурованим.
- Використовуйте функціональну декомпозицію (не пишіть всю логіку в одному методі).
- Ретельно протестуйте всі сценарії роботи програми.
## [Лабораторна робота 13](https://github.com/BohdanSharubin/java-university-project/tree/lab13)
### Вимоги до реалізації
- оновлений проєкт на основі Практичної №11;
- батьківський клас — abstract та реалізує Comparable;
- пункт меню №4 виводить відсортовані об’єкти;
- код протестований, помилки оброблені;
- код завантажений у ваш GitHub-репозиторій.
## [Лабораторна робота 14](https://github.com/BohdanSharubin/java-university-project/tree/lab14)
### Вимоги до реалізації
- Після вибору критерію програма повинна:
- відсортувати список об’єктів за обраним Comparator;
- вивести відсортовану інформацію в консоль.
- Дозволено використовувати Collections.sort(list, comparator) або list.sort(comparator).
## [Лабораторна робота 15](https://github.com/BohdanSharubin/java-university-project/tree/lab15)
### Вимоги до реалізації
- Не використовуйте var та goto.
- Всі озвучені під час занять вимоги до завдань та вимоги до попередніх робіт залишаються в силі та мусять бути виконані і в цьому завданні.
- Код має бути ретельно протестований (перевірте роботу меню, додавання/видалення/редагування об’єктів, виведення та сортування за всіма критеріями).
- ## [Лабораторна робота 16](https://github.com/BohdanSharubin/java-university-project/tree/lab16)
### Завдання 1
### Вимоги до реалізації
- Додайте інтерфейс Identifiable. 
    - Створіть інтерфейс, який задає контракт отримання UUID:

```
public interface Identifiable {
    UUID getUuid();
}
```

- Додайте UUID у ваші об’єкти.
    - Додайте поле UUID у батьківський клас (рекомендовано) або у всі класи ієрархії:
```
private UUID uuid;
```
- UUID має створюватися автоматично при створенні об’єкта:
```
uuid = UUID.randomUUID();
```
- Батьківський клас (або потрібні класи) має реалізувати Identifiable і повертати UUID через getUuid().
- Оновіть відображення об’єктів.
- Оновіть toString() так, щоб UUID був видимий у виводі (або зробіть окремий “короткий вивід”, див. Завдання 2).
- Додайте пошук за UUID.
  - У вашому функціоналі пошуку додайте метод (або окрему опцію пошуку), який:
приймає UUID (рядком), перетворює його в UUID;
  - знаходить об’єкт у колекції за UUID;
  - виводить дані об’єкта або повідомлення “не знайдено”.
  - Некоректний формат UUID має бути оброблений без падіння програми.